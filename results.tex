\section{Preliminary Results}
\label{sec-results}

To explore the potential to transform our discarded Nexus~S~4G smartphones
into low-power sensors, the authors divided into two teams and engaged in a
lifetime programming competition. Each team was provided five discarded
Nexus~S~4G phones and given two weeks to write a program that recorded
battery and light levels every 15~minutes and transmitted them to a server
over a Wifi connection. The goal was to implement a sensing application that
would last as long as possible, while maintaining data delivery to the
server. A gap of over two hours in the data values as observed by the other
team rendered the node as dead, regardless of the amount of energy it had
reported, with the two hour delay chosen to represent the potential
requirements of a somewhat delay-tolerant application.

\begin{figure}[t]
\includegraphics[width=\columnwidth]{./figures/comparison.pdf}

\caption{\small Lifetime results for two light sensing applications.
\textnormal{Both the Tiny Sensor Android (Section~\ref{subsec-tiny}) and
Sensor Android (Section~\ref{subsec-full}) approaches were projected to
achieve a lifetime of 8--9 days.}}

\label{fig-comparison}
\end{figure}


\XXXnote{Overall results.}

Broadly speaking the teams both explored two different options with important
implications for reuse in this context: starting with a stock AOSP platform
build and the familiar Android API, or using a super-minimal Tiny Android
build that discards most of the platform components. We refer to the first
approach as ``Sensor Android'' and the second as ``Tiny Sensor Android''.
From a programming perspective, we were hopeful that we could preserve the
familiar Android environment that many programmers today are learning. But
from an energy management persective, we were worried that the platform
contained features designed around short lifetimes that would prove
unhelpful. We describe both approaches in more detail below.

\subsection{Tiny Sensor Android}
\label{subsec-tiny}

Tiny Android is a development option enabling a stripped-down build intended
for testing new devices, and was not suitable for our application without
modifications. Wifi drivers had be added to the build process, and these
created several other dependencies. Our Tiny Sensor Android build added
\XXXnote{GWA : Guru TODO} packages to the \XXXnote{GWA : Guru TODO} normally
used by Tiny Android.

\XXXnote{GWA : Guru TODO : One or two paragraphs about the implementation.}

Figure~\ref{fig-tinyandroid} shows current output for one sense-and-send
cycle of our sensing application on Tiny Sensor Android. While the sensing
and transmission complete quickly, allowing the phone to rapidly return to
idle, there was an extra 8~mA of current during the idle state which we have
yet to explain. We believe it may be caused by \XXXnote{GWA : Guru TODO}.

\begin{figure}[t]
\includegraphics[width=\columnwidth]{./figures/samplecomparison.pdf}

\caption{\small Current draw for a single sense-and-send cycle.
\textnormal{Both the Tiny Sensor Android (Section~\ref{subsec-tiny}) and
            Sensor Android (Section~\ref{subsec-full}) have similar current draw for sensing and sending.}}

\label{fig-tinyandroid}
\end{figure}


\subsection{Sensor Android}
\label{subsec-full}

\XXXnote{GWA: Anand TODO} 
The image for the Sensor Android build was built from the latest available AOSP code from the JRO03R branch.
No changes were made to the platform as we wanted to measure the performance of stock AOSP against TINY Android build.
However we manually disabled all the default apps like Browser, Calendar, Email, etc. through the settings to disable some of the background services spawned by these applications. 
Although this could have been done during the building of the platform, we didn't want to change the stock platform to keep the application development process as simple as possible.

The sensing application was written in 291 loc using the available API's provided by Android framework. 
Before the start of the experiment, We assigned a static IP to the Wifi interface and the phone was put into Airplane mode to 
disable the cellular radio, Android allows users to use other radios like the Wifi to be enabled in airplane mode.
The sensing application controlled the enabling and disabling of the Wifi radio interface for each sensing period.

Figure~\ref{fig-tinyandroid} shows the current output for one sense-and-send cycle of our sensing application on the Sensor Android. Our sensing application 
completes the sense and send cycle quickly comparable to Tiny Sensor, This is seen in the high current draw phase in the graph, however we notice that there is a 60 second long tail before
the phone completly goes to idle state. On further investigation, we found that the ConnectivityService in Android holds a Wakelock for 60 seconds to allow other radio interfaces to connect
after one of the interfaces is disconnected. For our sensing application this is not required and the Platform code can be easily modified to remove this behavior.



\subsection{Comparison}
